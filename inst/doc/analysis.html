<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Analysis</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
</head>
<body>
<div class="include-before">
</div>
<div class="frontmatter">
<div class="title"><h1>Analysis</h1></div>
<div class="author"><h2></h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="body">
<p><strong>This file contains the code for reproducing the results shown in the related manuscript (numbers, tables, figures). We obtained our results on 2023-09-24 using R version 4.3.0 (2023-04-21) running natively on a MacBook Pro (2020) with an Apple M1 chip, 16 GB memory, and the operating system macOS Ventura (version 13.5.2). The total computation time was around 11 hours.</strong></p>
<h1 id="initialisation">Initialisation</h1>
<p>Choose the directory containing the sub-directories “data”, “results” and “manuscript”.</p>
<ul>
<li>
<p>The directory “data” may be empty for the first external application (<em>script loads data - which are also available <a href="https://github.com/markvdwiel/GRridge/blob/master/data/dataVerlaat.rda">here</a> - from the R package <a href="https://doi.org/10.18129/B9.bioc.GRridge"><code>GRridge</code></a></em>) but must contain the file “pone.0181468.s001.csv” for the second external application (<em>available from <a href="https://doi.org/10.1371/journal.pone.0181468">Erez et al. 2017</a> in the supporting file <a href="https://doi.org/10.1371/journal.pone.0181468.s001">journal.pone.0181468.s001.csv</a></em>) and the files “vcf_with_pvalue.tab” and “LuxPark_pheno.txt” for the internal application (<em>available upon request to [<a href="mailto:request.ncer-pd@uni.lu">request.ncer-pd@uni.lu</a>](<a href="mailto:request.ncer-pd@uni.lu">mailto:request.ncer-pd@uni.lu</a>?cc=<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>,<a href="mailto:enrico.glaab@uni.lu">enrico.glaab@uni.lu</a>&amp;subject=data request Rauschenberger et al. (“transreg”))</em>). For the internal application, this directory will also contain the intermediate file “app_int_data.RData”.</p>
</li>
<li>
<p>The directory “results” will contain the files “sim_int.RData” and “sim_ext.RData” for the external and internal simulation, the file “app_grridge.RData” for the first external application, the file “app_fwelnet.RData” for the second external application, and the file “app_int.RData” for the internal application.</p>
</li>
<li>
<p>The directory “manuscript” will contain the files “table_int.tex” and “table_ext.tex” for the internal and external simulations, the file “figure_example.pdf” for the methods section, the file “figure_ext.pdf” for the external applications, and the file “figure_int.pdf” for the internal application.</p>
</li>
</ul>
<pre><code class="language-r">rm(list=ls())
dir &lt;- &quot;~/Desktop/transreg&quot; # physical machine
#dir &lt;- &quot;/home/armin.rauschenberger/transreg&quot; # virtual machine
setwd(dir)
if(!all(c(&quot;data&quot;,&quot;results&quot;,&quot;manuscript&quot;) %in% dir())){
 stop(&quot;Missing folders!&quot;) 
}
</code></pre>
<p>Install missing R packages from CRAN and GitHub. Note that <code>ecpc</code> is and <code>transreg</code> will also be available on CRAN. For package versions, see session information at the end of this document and in the text files associated with each R data file.</p>
<pre><code class="language-r">pkgs &lt;- c(&quot;devtools&quot;,&quot;palasso&quot;,&quot;glmtrans&quot;,&quot;xtable&quot;,&quot;ecpc&quot;,&quot;xrnet&quot;)
utils::install.packages(setdiff(pkgs,rownames(installed.packages())))
remotes::install_github(&quot;markvdwiel/GRridge&quot;) # ref=&quot;ef706afe&quot;, version 1.7.5
remotes::install_github(&quot;kjytay/fwelnet&quot;) # ref=&quot;5515fd2e&quot;, version 0.1
remotes::install_github(&quot;LCSB-BDS/transreg&quot;) # ref=&quot;82757441&quot;, version 1.0.0
rm(pkgs)
</code></pre>
<h1 id="methods">Methods</h1>
<p>The following chunk generates the figure for the methods section.</p>
<ul>
<li>
<p>input: none (<em>simulating data</em>)</p>
</li>
<li>
<p>execution time: some seconds</p>
</li>
<li>
<p>output: manuscript/figure_example.pdf</p>
</li>
</ul>
<pre><code class="language-r">#&lt;&lt;init&gt;&gt;
#grDevices::pdf(file=paste0(dir,&quot;/manuscript/figure_example.pdf&quot;),width=8,height=5,pointsize=15)
#grDevices::png(file=paste0(dir,&quot;/manuscript/figure_example.png&quot;),width=8,height=5,units=&quot;in&quot;,pointsize=15,res=1200)
grDevices::postscript(file=paste0(dir,&quot;/manuscript/figure_example.eps&quot;),width=8,height=5,pointsize=15,horizontal=FALSE,paper=&quot;special&quot;)

set.seed(1)
n &lt;- 200; p &lt;- 500
X &lt;- matrix(stats::rnorm(n*p),nrow=n,ncol=p)
temp &lt;- stats::rnorm(p)
range &lt;- stats::qnorm(p=c(0.01,0.99))
temp[temp&lt;range[1]] &lt;- range[1]
temp[temp&gt;range[2]] &lt;- range[2]

beta &lt;- list()
beta$ident &lt;- temp
beta$sqrt &lt;- sign(temp)*sqrt(abs(temp))
beta$quad &lt;- sign(temp)*abs(temp)^2
beta$trunc &lt;- ifelse(temp&lt;=0,0,temp)
beta$step &lt;- ifelse(temp&lt;=1,0,1)
beta$combn &lt;- ifelse(temp&lt;0,sign(temp)*sqrt(abs(temp)),sign(temp)*abs(temp)^2)

graphics::par(mfrow=c(2,3),mar=c(3,3,0.5,0.5))
for(i in seq_along(beta)){
  
  prior &lt;- matrix(temp,ncol=1)
  eta &lt;- X %*% beta[[i]]
  y &lt;- stats::rnorm(n=n,mean=eta,sd=sd(eta))
  a &lt;- transreg:::.exp.multiple(y=y,X=X,prior=prior,family=&quot;gaussian&quot;,select=FALSE)
  b &lt;- transreg:::.iso.fast.single(y=y,X=X,prior=prior,family=&quot;gaussian&quot;)

  graphics::plot.new()
  graphics::plot.window(xlim=range(prior,-prior),ylim=range(a$beta,b$beta))
  graphics::axis(side=1)
  graphics::axis(side=2)
  graphics::abline(h=0,lty=2,col=&quot;grey&quot;)
  graphics::abline(v=0,lty=2,col=&quot;grey&quot;)
  graphics::box()
  graphics::title(xlab=expression(z),ylab=expression(gamma),line=2)
  graphics::points(x=prior,y=a$beta,col=&quot;red&quot;,cex=0.7)
  graphics::points(x=prior,y=b$beta,col=&quot;blue&quot;,cex=0.7)
  graphics::lines(x=prior[order(prior)],y=beta[[i]][order(prior)],lwd=1.2)
  graphics::legend(x=&quot;topleft&quot;,legend=paste0(&quot;(&quot;,i,&quot;)&quot;),bty=&quot;n&quot;,x.intersp=0)
}

grDevices::dev.off()
</code></pre>
<h1 id="simulations">Simulations</h1>
<p>The following chunk performs the external (<code>glmtrans</code>) and the internal simulation.</p>
<ul>
<li>
<p>input: none (<em>simulating data</em>)</p>
</li>
<li>
<p>execution time: <strong>2 + 1 = 3 hours</strong></p>
</li>
<li>
<p>output: results/sim_ext.RData, results/sim_int.RData, results/info_sim.RData</p>
</li>
</ul>
<pre><code class="language-r">#&lt;&lt;init&gt;&gt;

# - - - modify glmtrans::models function - - -
glmtrans.models &lt;- glmtrans::models
string &lt;- base::deparse(glmtrans.models)
# return target beta
string &lt;- gsub(pattern=&quot;list\\(x \\= NULL, y \\= NULL\\)&quot;,
               replacement=&quot;list(x = NULL, y = NULL, beta = wk)&quot;,
               x=string)
# return source beta
string &lt;- gsub(pattern=&quot;list\\(x \\= x, y \\= y\\)&quot;,
               replacement=&quot;list(x = x, y = y, beta = wk)&quot;,
               x=string)
glmtrans.models &lt;- eval(parse(text=string))
rm(string)
# - - - - - - - - - - - - - - - - - - - - - -

for(mode in c(&quot;ext&quot;,&quot;int&quot;)){
  
    # simulation setting
    if(mode==&quot;ext&quot;){
      frame &lt;- expand.grid(seed=1:10,
                           Ka=as.integer(c(1,3,5)),
                           K=as.integer(5),
                           h=as.integer(c(5,250)),
                           alpha=as.integer(c(0,1)),
                           family=c(&quot;gaussian&quot;,&quot;binomial&quot;)
                           )
    } else if(mode==&quot;int&quot;){
      frame &lt;- expand.grid(seed=1:10,
                           rho.x=c(0.95,0.99),
                           rho.beta=c(0.6,0.8,0.99),
                           alpha=as.integer(c(0,1)),
                           family=c(&quot;gaussian&quot;,&quot;binomial&quot;)
                           )
    }
    frame$family &lt;- as.character(frame$family)
    frame[,c(&quot;cor.x&quot;,&quot;cor.beta&quot;,&quot;mean&quot;,&quot;glmnet&quot;,&quot;glmtrans&quot;,&quot;transreg&quot;)] &lt;- NA
    n0 &lt;- 100; n1 &lt;- 10000
    n.target &lt;- n0+n1
    foldid.ext &lt;- rep(c(0,1),times=c(n0,n1))
    
    for(iter in seq_len(nrow(frame))){
      cat(paste0(mode,&quot;: &quot;,iter,&quot;/&quot;,nrow(frame),&quot;\n&quot;))
      
      if(!is.na(frame$seed[iter])){set.seed(frame$seed[iter])}

      # data simulation
      if(mode==&quot;ext&quot;){ 
        message(&quot;Using external simulation study!&quot;)
        s &lt;- ifelse(frame$alpha[iter]==0,50,15)
        data &lt;- glmtrans.models(family=frame$family[iter],type=&quot;all&quot;,
                                p=1000,n.target=n.target,s=s,
                                Ka=frame$Ka[iter],K=frame$K[iter],h=frame$h[iter])
        target &lt;- data$target
        source &lt;- data$source
        beta &lt;- cbind(sapply(data$source,function(x) x$beta),data$target$beta)
      } else if(mode==&quot;int&quot;){
        message(&quot;Using internal simulation study!&quot;)
        prop &lt;- ifelse(frame$alpha[iter]==0,0.3,0.05)
        data &lt;- transreg:::simulate(p=500,n.target=n.target,family=frame$family[iter],
                                prop=prop,rho.beta=frame$rho.beta[iter],w=0.8,
                                rho.x=frame$rho.x[iter],k=3,exp=c(1,2,0.5),
                                trans=c(FALSE,TRUE,TRUE))
        target &lt;- data$target
        source &lt;- data$source
        beta &lt;- data$beta
      }
      
      # correlation
      temp &lt;- abs(stats::cor(data$target$x,method=&quot;pearson&quot;))
      temp[lower.tri(temp,diag=TRUE)] &lt;- NA
      frame$cor.x[iter] &lt;- mean(temp,na.rm=TRUE)
      temp &lt;- abs(stats::cor(beta,method=&quot;pearson&quot;))
      temp[lower.tri(temp,diag=TRUE)] &lt;- NA
      frame$cor.beta[iter] &lt;- max(temp[,ncol(temp)],na.rm=TRUE)
      
      # predictive performance
      loss &lt;- transreg:::compare(target=target,source=source,
                          family=frame$family[iter],alpha=frame$alpha[iter],
                          foldid.ext=foldid.ext,nfolds.ext=1,
                          scale=c(&quot;exp&quot;,&quot;iso&quot;),
                          sign=FALSE,switch=FALSE,select=TRUE,alpha.prior=NULL,
                          seed=frame$seed[iter],xrnet=TRUE)
      frame[iter,names(loss$deviance)] &lt;- loss$deviance
    }
    save(frame,file=paste0(dir,&quot;/results/sim_&quot;,mode,&quot;.RData&quot;))
}
writeLines(text=capture.output(utils::sessionInfo(),cat(&quot;\n&quot;),
      sessioninfo::session_info()),con=paste0(dir,&quot;/results/info_sim.txt&quot;))
</code></pre>
<p>The following chunk generates the tables for the external (<code>glmtrans</code>) and the internal simulation. <strong>Requires execution of previous chunk.</strong></p>
<ul>
<li>
<p>input: results/sim_ext.RData, results/sim_int.RData</p>
</li>
<li>
<p>execution time: some seconds</p>
</li>
<li>
<p>output: manuscript/table_ext.tex, manuscript/table_int.tex</p>
</li>
</ul>
<pre><code class="language-r">rm(list=ls())
dir &lt;- &quot;~/Desktop/transreg&quot; # physical machine
#dir &lt;- &quot;/home/armin.rauschenberger/transreg&quot; # virtual machine
setwd(dir)
if(!all(c(&quot;data&quot;,&quot;results&quot;,&quot;manuscript&quot;) %in% dir())){
 stop(&quot;Missing folders!&quot;) 
}
for(mode in c(&quot;ext&quot;,&quot;int&quot;)){
    file &lt;- paste0(dir,&quot;/results/sim_&quot;,mode,&quot;.RData&quot;)
    #if(mode==&quot;int&quot;){file &lt;- &quot;~/Desktop/transreg/results/sim_int_fast.RData&quot;}
    if(!file.exists(file)){warning(&quot;Missing file &quot;,file,&quot;.&quot;);next}
    load(file)
    colnames(frame) &lt;- gsub(pattern=&quot;transreg.&quot;,replacement=&quot;&quot;,x=colnames(frame))
    
    info.var &lt;- c(&quot;Ka&quot;,&quot;h&quot;,&quot;rho.x&quot;,&quot;rho.beta&quot;,&quot;alpha&quot;,&quot;family&quot;)
    info &lt;- frame[,colnames(frame) %in% info.var]
    info.name &lt;- gsub(pattern=&quot; &quot;,replacement=&quot;&quot;,x=apply(info,1,function(x) paste0(x,collapse=&quot;.&quot;)))
    number &lt;- as.numeric(factor(info.name,levels=unique(info.name)))
    info &lt;- unique(info)
    info$cor.beta &lt;- info$cor.x &lt;- NA
    
    loss.var &lt;- c(&quot;glmnet&quot;,&quot;glmtrans&quot;,&quot;xrnet&quot;,&quot;exp.sta&quot;,&quot;exp.sim&quot;,&quot;iso.sta&quot;,&quot;iso.sim&quot;)
    loss &lt;- frame[,c(loss.var,&quot;mean&quot;)]
    # as percentage of empty model
    loss &lt;- 100*loss/loss$mean
  
    # average over 10 different seeds
    both &lt;- mean &lt;- sd &lt;- p.better &lt;- p.worse &lt;- matrix(NA,nrow=max(number),ncol=length(loss.var),dimnames=list(1:max(number),loss.var))
    for(i in 1:max(number)){
      for(j in seq_along(loss.var)){
        cond &lt;- number==i
        x &lt;- loss$glmnet[cond]
        y &lt;- loss[[loss.var[j]]][cond]
        p.better[i,j] &lt;- stats::wilcox.test(x=x,y=y,paired=TRUE,alternative=&quot;greater&quot;,exact=FALSE)$p.value
        p.worse[i,j] &lt;- stats::wilcox.test(x=x,y=y,paired=TRUE,alternative=&quot;less&quot;,exact=FALSE)$p.value
        mean[i,j] &lt;- mean(y)
        sd[i,j] &lt;- sd(y)
        info$cor.x[i] &lt;- mean(frame$cor.x[cond])
        info$cor.beta[i] &lt;- mean(frame$cor.beta[cond])
      }
    }
    
    front &lt;- format(round(mean,digits=1),trim=TRUE)
    front.nchar &lt;- nchar(front)
    back &lt;- format(round(sd,digits=1),trim=TRUE)
    back.nchar &lt;- nchar(back)
    
    both[] &lt;- paste0(front,&quot;$\\pm$&quot;,back)
    
    grey &lt;- mean&gt;=mean[,&quot;glmnet&quot;]
    both[grey] &lt;- paste0(&quot;\\textcolor{gray}{&quot;,both[grey],&quot;}&quot;)
    
    min &lt;- cbind(seq_len(max(number)),apply(mean,1,which.min))
    both[min] &lt;- paste0(&quot;\\underline{&quot;,both[min],&quot;}&quot;)

    star &lt;- p.better&lt;=0.05
    both[star] &lt;- paste0(both[star],&quot;*&quot;)
    #both[!star] &lt;- paste0(both[!star],&quot;\\phantom{*}&quot;) 
    
    dagger &lt;- p.worse&lt;=0.05
    both[dagger] &lt;- paste0(both[dagger],&quot;$\\dagger$&quot;)
    both[!star &amp; !dagger] &lt;- paste0(both[!star &amp; !dagger],&quot;\\phantom{*}&quot;) 
    
    both[front.nchar==3] &lt;- paste0(&quot;$~$&quot;,both[front.nchar==3])
    both[back.nchar==3] &lt;- paste0(both[back.nchar==3],&quot;$~$&quot;)
    
    external &lt;- &quot;number of transferable source data sets ($K_a$), differences between source and target coefficients ($h$), dense setting with ridge regularisation ($s=50$, $\\alpha=0$) or sparse setting with lasso regularisation ($s=15$, $\\alpha=1$), family of distribution (`gaussian' or `binomial').&quot;
    internal &lt;- &quot;correlation parameter for features ($\\rho_x$), correlation parameter for coefficients ($\\rho_{\\beta}$), dense setting with ridge regularisation ($\\pi=30\\%$, $\\alpha=0$) or sparse setting with lasso regularisation ($\\pi=5\\%$, $\\alpha=1$), family of distribution (`gaussian' or `binomial').&quot;
    caption &lt;- paste0(&quot;Predictive performance in &quot;,mode,&quot;ernal simulation. In each setting (row), we simulate $10$ data sets, calculate the performance metric (mean-squared error for numerical prediction, logistic deviance for binary classification) for the test sets, express these metrics as percentages of those from prediction by the mean, and show the mean and standard deviation of these percentages. Settings: &quot;,ifelse(mode==&quot;ext&quot;,external,ifelse(mode==&quot;int&quot;,internal,NULL)),&quot; These parameters determine (i) the mean Pearson correlation among the features in the target data set ($\\bar{\\rho}_x$) and (ii) the maximum Pearson correlation between the coefficients in the target data set and the coefficients in the source data sets ($\\max(\\hat{\\rho}_{\\beta})$). Methods: regularised regression (\\texttt{glmnet}), competing transfer learning methods (\\texttt{glmtrans} , \\texttt{xrnet}), proposed transfer learning method (\\texttt{transreg}) with exponential/isotonic calibration and standard/simultaneous stacking. In each setting, the colour black (grey) highlights methods that are more (less) predictive than regularised regression without transfer learning (\\texttt{glmnet}), asterisks (daggers) indicate methods that are \\textit{significantly} more (less) predictive at the 5\\% level (one-sided Wilcoxon signed-rank test), and an underline highlights the most predictive method. \\label{sim_&quot;,mode,&quot;}&quot;)
    
    colnames(info) &lt;- sapply(colnames(info),function(x) switch(x,&quot;Ka&quot;=&quot;$K_a$&quot;,&quot;K&quot;=&quot;$K$&quot;,&quot;h&quot;=&quot;$h$&quot;,&quot;alpha&quot;=&quot;$\\alpha$&quot;,&quot;rho.x&quot;=&quot;$\\rho_x$&quot;,&quot;rho.beta&quot;=&quot;$\\rho_\\beta$&quot;,&quot;cor.x&quot;=&quot;$\\bar{\\rho}_{x}$&quot;,&quot;cor.beta&quot;=&quot;$\\max(\\hat{\\rho}_{\\beta})$&quot;,&quot;cor.t&quot;=&quot;$\\bar{\\rho}_{a}$&quot;,x))
    colnames(both) &lt;- paste0(&quot;\\texttt{&quot;,colnames(both),&quot;}&quot;)
    
    align &lt;- paste0(&quot;|r|&quot;,paste0(rep(&quot;c&quot;,times=ncol(info)),collapse=&quot;&quot;),&quot;|&quot;,paste0(rep(&quot;c&quot;,times=ncol(both)),collapse=&quot;&quot;),&quot;|&quot;)
    
    add.to.row &lt;- list()
    add.to.row$pos &lt;- list(-1)
    add.to.row$command &lt;- &quot;\\multicolumn{9}{c}{~} &amp; \\multicolumn{4}{|c|}{\\texttt{transreg}}\\\\&quot;
    
    xtable &lt;- xtable::xtable(x=cbind(info,both),align=align,caption=caption)
    xtable::print.xtable(x=xtable,
                include.rownames=FALSE,
                floating=TRUE,
                sanitize.text.function=identity,
                comment=FALSE,
                caption.placement=&quot;top&quot;,
                floating.environment=&quot;table*&quot;,
                #size=&quot;\\small \\setlength{\\tabcolsep}{3pt}&quot;,
                file=paste0(dir,&quot;/manuscript/table_&quot;,mode,&quot;.tex&quot;),
                add.to.row=add.to.row,
                hline.after=c(-1,0,nrow(xtable)))
}
</code></pre>
<h1 id="external-applications">External applications</h1>
<p>The following chunk performs the first external application (<code>GRridge</code>).</p>
<ul>
<li>
<p>input: none (<em>script loads data - which are also available <a href="https://github.com/markvdwiel/GRridge/blob/master/data/dataVerlaat.rda">here</a> - from the R package <a href="https://doi.org/10.18129/B9.bioc.GRridge"><code>GRridge</code></a></em>)</p>
</li>
<li>
<p>execution time: <strong>2.5 hours</strong></p>
</li>
<li>
<p>output: results/app_grridge.RData, results/info_app_grridge.txt</p>
</li>
</ul>
<pre><code class="language-r">#&lt;&lt;init&gt;&gt;
data(dataVerlaat,package=&quot;GRridge&quot;)

target &lt;- list()
target$y &lt;- as.numeric(as.factor(respVerlaat))-1
target$x &lt;- t(datcenVerlaat)

z &lt;- -log10(pvalFarkas) # ecpc and fwelnet
prior &lt;- sign(diffmeanFarkas)*(-log10(pvalFarkas)) # transreg

loss &lt;- list()
for(i in 1:10){
  cat(&quot;---&quot;,i,&quot;---\n&quot;)
  loss[[i]] &lt;- transreg:::compare(target=target,prior=prior,z=as.matrix(z,ncol=1),
                                    family=&quot;binomial&quot;,alpha=0,scale=c(&quot;exp&quot;,&quot;iso&quot;),sign=FALSE,switch=FALSE,select=FALSE,type.measure=c(&quot;deviance&quot;,&quot;class&quot;,&quot;auc&quot;),seed=i,xrnet=TRUE)
}
save(loss,file=paste0(dir,&quot;/results/app_grridge.RData&quot;))
writeLines(text=capture.output(utils::sessionInfo(),cat(&quot;\n&quot;),
      sessioninfo::session_info()),con=paste0(dir,&quot;/results/info_app_grridge.txt&quot;))

load(paste0(dir,&quot;/results/app_grridge.RData&quot;),verbose=TRUE)
table &lt;- as.data.frame(t(sapply(loss,function(x) x$deviance)))
table &lt;- (table-table$glmnet)/table$glmnet
table &lt;- table[,c(&quot;glmnet&quot;,&quot;transreg.exp.sta&quot;,&quot;transreg.exp.sim&quot;,&quot;transreg.iso.sta&quot;,&quot;transreg.iso.sim&quot;,&quot;fwelnet&quot;,&quot;ecpc&quot;,&quot;xrnet&quot;)]
sapply(table[,-1],function(x) sum(x&lt;table$glmnet))
round(100*colMeans(table[,-1]),digits=2)
</code></pre>
<p>The following chunk performs the second external application (<code>fwelnet</code>).</p>
<ul>
<li>
<p>input: data/pone.0181468.s001.csv (<em>available from <a href="https://doi.org/10.1371/journal.pone.0181468">Erez et al. 2017</a> in the supporting file <a href="https://doi.org/10.1371/journal.pone.0181468.s001">journal.pone.0181468.s001.csv</a></em>)</p>
</li>
<li>
<p>execution time: <strong>0.5 hours</strong></p>
</li>
<li>
<p>output: results/app_fwelnet.RData, results/info_app_fwelnet.txt</p>
</li>
</ul>
<pre><code class="language-r">#&lt;&lt;init&gt;&gt;

table &lt;- utils::read.csv(&quot;data/pone.0181468.s001.csv&quot;,header=TRUE,skip=3)

extract &lt;- function(cond,y,X,id){
  if(length(unique(c(length(cond),length(y),nrow(X),length(id))))!=1){stop(&quot;Invalid input.&quot;)}
  n &lt;- table(id,cond)[,&quot;TRUE&quot;]
  y &lt;- y[cond]
  X &lt;- X[cond,]
  id &lt;- id[cond]
  weights &lt;- rep(1/n,times=n)
  ids &lt;- unique(id)
  ys &lt;- sapply(ids,function(x) unique(y[id==x]))
  foldid &lt;- rep(NA,length=length(ids))
  foldid[ys==0] &lt;- sample(rep(1:10,length.out=sum(ys==0)))
  foldid[ys==1] &lt;- sample(rep(1:10,length.out=sum(ys==1)))
  foldid &lt;- rep(foldid,times=n[n!=0])
  if(length(unique(c(length(y),nrow(X),length(weights),length(foldid))))!=1){
    stop(&quot;Invalid output.&quot;)
  }
  return(list(y=y,x=X,weights=weights,foldid=foldid))
}

loss &lt;- ridge &lt;- lasso &lt;- list()
for(i in 1:10){
  cat(&quot;---&quot;,i,&quot;---\n&quot;)
  set.seed(i)
  
  y &lt;- table$LatePE
  X &lt;- as.matrix(table[,grepl(pattern=&quot;SL&quot;,x=colnames(table))])
  X &lt;- scale(X)
  
  min &lt;- sapply(unique(table$ID),function(i) min(table$GA[table$ID==i]))
  max &lt;- sapply(unique(table$ID),function(i) max(table$GA[table$ID==i]))
  
  limit &lt;- 20
  group &lt;- stats::rbinom(n=max(table$ID),size=1,prob=0.5)
  source.id &lt;- which(group==0 | min &gt; limit)
  target.id &lt;- which(group==1 &amp; min &lt;= limit)
  if(any(!table$ID %in% c(source.id,target.id))){stop()}
  if(any(!c(source.id,target.id) %in% table$ID)){stop()}
  if(any(duplicated(c(source.id,target.id)))){stop()}
  
  source &lt;- list()
  source[[1]] &lt;- extract(cond=(table$ID %in% source.id) &amp; (table$GA&lt;=limit),y=y,X=X,id=table$ID)
  source[[2]] &lt;- extract(cond=(table$ID %in% source.id),y=y,X=X,id=table$ID)
  
  prior &lt;- z &lt;- matrix(NA,nrow=ncol(X),ncol=length(source))
  for(j in seq_along(source)){
    base &lt;- glmnet::cv.glmnet(y=source[[j]]$y,x=source[[j]]$x,
                              family=&quot;binomial&quot;,alpha=0,
                              weights=source[[j]]$weights,
                              foldid=source[[j]]$foldid)
    prior[,j] &lt;- coef(base,s=&quot;lambda.min&quot;)[-1]
    z[,j] &lt;- abs(coef(base,s=&quot;lambda.min&quot;)[-1])
  }
  
  target &lt;- list()
  target$y &lt;- sapply(target.id,function(i) unique(y[table$ID==i]))
  target$x &lt;- t(sapply(target.id,function(i) X[table$ID==i &amp; table$GA==min(table$GA[table$ID==i]),]))
  
  loss[[i]] &lt;- transreg:::compare(target=target,prior=prior,family=&quot;binomial&quot;,alpha=0,scale=c(&quot;exp&quot;,&quot;iso&quot;),sign=FALSE,switch=FALSE,select=FALSE,z=z,type.measure=c(&quot;deviance&quot;,&quot;class&quot;,&quot;auc&quot;),seed=i,xrnet=TRUE)
}
save(loss,file=paste0(dir,&quot;/results/app_fwelnet.RData&quot;))
writeLines(text=capture.output(utils::sessionInfo(),cat(&quot;\n&quot;),
      sessioninfo::session_info()),con=paste0(dir,&quot;/results/info_app_fwelnet.txt&quot;))

load(paste0(dir,&quot;/results/app_fwelnet.RData&quot;))
table &lt;- as.data.frame(t(sapply(loss,function(x) x$deviance)))
table &lt;- (table-table$glmnet)/table$glmnet
table &lt;- table[,c(&quot;glmnet&quot;,&quot;transreg.exp.sta&quot;,&quot;transreg.exp.sim&quot;,&quot;transreg.iso.sta&quot;,&quot;transreg.iso.sim&quot;,&quot;fwelnet&quot;,&quot;ecpc&quot;,&quot;xrnet&quot;)]
sapply(table[,-1],function(x) sum(x&lt;table$glmnet))
round(100*colMeans(table[,-1]),digits=2)
</code></pre>
<p>The following chunk generates the figure for both external applications (<code>GRridge</code> and <code>fwelnet</code>). <strong>Requires execution of previous two chunks.</strong></p>
<ul>
<li>
<p>input: results/app_grridge.RData, results/app_fwelnet.RData</p>
</li>
<li>
<p>execution time: some seconds</p>
</li>
<li>
<p>output: manuscript/figure_ext.pdf</p>
</li>
</ul>
<pre><code class="language-r">#grDevices::pdf(file=paste0(dir,&quot;/manuscript/figure_ext.pdf&quot;),width=8,height=6,pointsize=15)
#grDevices::png(file=paste0(dir,&quot;/manuscript/figure_ext.png&quot;),width=8,height=6,units=&quot;in&quot;,pointsize=15,res=1200)
grDevices::postscript(file=paste0(dir,&quot;/manuscript/figure_ext.eps&quot;),width=8,height=6,pointsize=15,horizontal=FALSE,paper=&quot;special&quot;)
graphics::par(mfrow=c(2,1),mar=c(2.5,2.0,0.5,0.5))
for(k in c(&quot;grridge&quot;,&quot;fwelnet&quot;)){
  file &lt;- paste0(dir,&quot;/results/app_&quot;,k,&quot;.RData&quot;)
  if(!file.exists(file)){plot.new();next}
  load(file)
  loss &lt;- as.data.frame(t(sapply(loss,function(x) x$deviance)))
  colnames(loss) &lt;- gsub(pattern=&quot;transreg.&quot;,replacement=&quot;&quot;,x=colnames(loss))
  loss &lt;- 100*(loss-loss$glmnet)/loss$glmnet

  temp &lt;- c(&quot;exp.sta&quot;,&quot;exp.sim&quot;,&quot;iso.sta&quot;,&quot;iso.sim&quot;)
  name &lt;- c(&quot;fwelnet&quot;,&quot;ecpc&quot;,&quot;xrnet&quot;,temp)
  graphics::plot.new()
  graphics::plot.window(xlim=c(0.5,length(name)+0.5),ylim=range(loss,na.rm=TRUE))
  graphics::abline(h=0,lty=2,col=&quot;grey&quot;)
  #graphics::axis(side=1,at=seq_along(name),labels=name,cex.axis=0.7) # original
  cond &lt;- grepl(pattern=&quot;\\.&quot;,x=name)
  graphics::axis(side=1,at=seq_along(name),labels=rep(&quot;&quot;,times=length(name)))
  graphics::mtext(side=1,at=seq_along(name)[!cond],text=name[!cond],cex=0.7,line=1)
  graphics::mtext(side=1,at=seq_along(name)[cond],text=name[cond],cex=0.7,line=0.25)
  graphics::mtext(side=1,at=mean(seq_along(name)[cond]),text=&quot;transreg&quot;,cex=0.7,line=1)
  
  if(grepl(pattern=&quot;grridge&quot;,x=k)){at &lt;- seq(from=-10,to=10,by=5)}
  if(grepl(pattern=&quot;fwelnet&quot;,x=k)){at &lt;- seq(from=-20,to=20,by=10)}
  labels &lt;- ifelse(at==0,&quot;0%&quot;,ifelse(at&lt;0,paste0(at,&quot;%&quot;),paste0(&quot;+&quot;,at,&quot;%&quot;)))
  graphics::axis(side=2,cex.axis=0.7,at=at,labels=labels)
  #graphics::title(ylab=&quot;change in metric&quot;,line=2.5,cex.lab=0.7)
  graphics::box()
  for(i in seq_along(name)){
    palasso:::.boxplot(loss[,name[i]],at=i,invert=FALSE)
    graphics::points(x=i,y=mean(loss[,name[i]]),pch=22,col=&quot;white&quot;,bg=&quot;black&quot;,cex=0.7)
  }
}
grDevices::dev.off()
</code></pre>
<h1 id="internal-application">Internal application</h1>
<p>The following chunk performs the internal application.</p>
<ul>
<li>
<p>input: data/vcf_with_pvalue.tab, data/LuxPark_pheno.txt (<em>available upon request to [<a href="mailto:request.ncer-pd@uni.lu">request.ncer-pd@uni.lu</a>](<a href="mailto:request.ncer-pd@uni.lu">mailto:request.ncer-pd@uni.lu</a>?cc=<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>,<a href="mailto:enrico.glaab@uni.lu">enrico.glaab@uni.lu</a>&amp;subject=data request Rauschenberger et al. (“transreg”))</em>)</p>
</li>
<li>
<p>execution time: <strong>5.5 hours</strong> (parallel computing with 8 cores)</p>
</li>
<li>
<p>output: data/app_int_data.RData, results/app_int.RData, results/info_app_int.txt</p>
</li>
</ul>
<pre><code class="language-r">#&lt;&lt;init&gt;&gt;
geno &lt;- read.table(paste0(dir,&quot;/data/vcf_with_pvalue.tab&quot;),header=TRUE)

switch &lt;- ifelse(geno$REF==geno$A1_gwas &amp; geno$ALT==geno$A2_gwas,1,
                 ifelse(geno$REF==geno$A2_gwas &amp; geno$ALT==geno$A1_gwas,-1,0))
#prior &lt;- -geno$beta*switch # original effect sizes
prior &lt;- log10(geno$p_value)*sign(geno$beta)*switch # pseudo effect sizes
pvalue &lt;- geno$p_value

# Note: Why are pseudo-effect sizes more suitable as prior effects as compared to original effect sizes?
# graphics::plot(x=geno$beta,y=-log10(geno$p_value),xlim=c(-1,1),col=ifelse(stats::p.adjust(geno$p_value)&lt;=0.05,&quot;red&quot;,&quot;black&quot;))

X &lt;- geno[,grepl(pattern=&quot;ND&quot;,colnames(geno))]
X[X==&quot;0/0&quot;] &lt;- 0
X[X==&quot;0/1&quot;] &lt;- 1
X[X==&quot;1/1&quot;] &lt;- 1
X &lt;- sapply(X,as.numeric)
X &lt;- t(X)

pheno &lt;- read.delim(paste0(dir,&quot;/data/LuxPark_pheno.txt&quot;),sep=&quot; &quot;,header=FALSE)
y &lt;- ifelse(pheno$V2==1,0,ifelse(pheno$V2==2,1,NA)); names(y) &lt;- pheno$V1

names &lt;- intersect(names(y[!is.na(y)]),rownames(X))
X &lt;- X[names,]; y &lt;- y[names]

# Note: Are prior effects positively correlated with correlation between outcome and features?
# cor &lt;- as.numeric(stats::cor(y,X,method=&quot;spearman&quot;))
# graphics::plot(x=prior,y=cor,col=ifelse(stats::p.adjust(geno$p_value)&lt;=0.05,&quot;red&quot;,&quot;black&quot;))
# graphics::abline(h=0,lty=2,col=&quot;grey&quot;)

# descriptive statistics
sum(p.adjust(pvalue,method=&quot;BH&quot;)&lt;=0.05)
sum(p.adjust(pvalue,method=&quot;holm&quot;)&lt;=0.05)
mean(pvalue&lt;=0.05)
dim(X)
table(y)

# memory reduction
cond &lt;- pvalue &lt;= 0.05
X &lt;- X[,cond]
prior &lt;- prior[cond]
pvalue &lt;- pvalue[cond]
switch &lt;- switch[cond]

save(y,X,prior,pvalue,switch,file=paste0(dir,&quot;/data/app_int_data.RData&quot;))

load(paste0(dir,&quot;/data/app_int_data.RData&quot;))
power &lt;- seq(from=-2,to=-10,by=-1)
cutoff &lt;- 5*10^power
frame &lt;- expand.grid(cutoff=cutoff,alpha=0:1,seed=1:10,count=NA)

#- - - sequential (start) - - -
#loss &lt;- list()
#for(i in seq_len(nrow(frame))){
#  cat(&quot;--- i =&quot;,i,&quot;---&quot;,&quot;\n&quot;)
#  set.seed(frame$seed[i])
#  foldid &lt;- transreg:::.folds(y=y,nfolds.ext=10,nfolds.int=10)
#  cond &lt;- switch!=0 &amp; pvalue &lt; frame$cutoff[i]
#  loss[[i]] &lt;- transreg:::compare(target=list(y=y,x=X[,cond]),prior=prior[cond],family=&quot;binomial&quot;,alpha=frame$alpha[i],scale=c(&quot;exp&quot;,&quot;iso&quot;),sign=FALSE,switch=FALSE,select=FALSE,foldid.ext=foldid$foldid.ext,foldid.int=foldid$foldid.int,type.measure=c(&quot;deviance&quot;,&quot;class&quot;,&quot;auc&quot;),seed=frame$seed[i])
#  frame$count[i] &lt;- sum(cond)
#}
# - - - sequential (end) - - -

#- - - parallel (start) - - -
frame &lt;- expand.grid(cutoff=cutoff,alpha=0:1,seed=1:10,count=NA)
cluster &lt;- snow::makeCluster(8)
evaluate &lt;- function(frame,i,switch,pvalue,y,X,prior){
  set.seed(frame$seed[i])
  foldid &lt;- transreg:::.folds(y=y,nfolds.ext=10,nfolds.int=10)
  cond &lt;- switch!=0 &amp; pvalue &lt; frame$cutoff[i]
  transreg:::compare(target=list(y=y,x=X[,cond]),prior=prior[cond],family=&quot;binomial&quot;,alpha=frame$alpha[i],scale=c(&quot;exp&quot;,&quot;iso&quot;),sign=FALSE,switch=FALSE,select=FALSE,foldid.ext=foldid$foldid.ext,foldid.int=foldid$foldid.int,type.measure=c(&quot;deviance&quot;,&quot;class&quot;,&quot;auc&quot;),seed=frame$seed[i])
}
snow::clusterExport(cl=cluster,list=c(&quot;evaluate&quot;,&quot;frame&quot;,&quot;switch&quot;,&quot;pvalue&quot;,&quot;y&quot;,&quot;X&quot;,&quot;prior&quot;))
loss &lt;- snow::parSapply(cl=cluster,X=seq_len(nrow(frame)),FUN=function(i) evaluate(frame=frame,i=i,switch=switch,pvalue=pvalue,y=y,X=X,prior=prior),simplify=FALSE)
#- - - parallel (end) - - -

save(frame,loss,file=paste0(dir,&quot;/results/app_int.RData&quot;))
writeLines(text=capture.output(utils::sessionInfo(),cat(&quot;\n&quot;),
      sessioninfo::session_info()),con=paste0(dir,&quot;/results/info_app_int.txt&quot;))
</code></pre>
<p>The following chunk generates the figures for the internal application. <strong>Requires execution of previous chunk.</strong></p>
<ul>
<li>
<p>input: results/app_int.RData</p>
</li>
<li>
<p>execution time: some seconds</p>
</li>
<li>
<p>output: manuscript/figure_int.pdf, manuscript/figure_temp.pdf</p>
</li>
</ul>
<pre><code class="language-r">#&lt;&lt;init&gt;&gt;

plotter &lt;- function(table,cutoff,number,horizontal=FALSE){
  graphics::par(mfrow=c(2,2),mar=c(3,1.8,1.0,0.9))
  for(scale in c(&quot;exp&quot;,&quot;iso&quot;)){
    for(alpha in c(&quot;0&quot;,&quot;1&quot;)){
      graphics::plot.new()
      graphics::plot.window(xlim=range(log(cutoff)),ylim=range(table))
      graphics::box()
      graphics::title(main=paste(ifelse(alpha==0,&quot;ridge&quot;,ifelse(alpha==1,&quot;lasso&quot;,NA)),&quot;-&quot;,scale),cex.main=1,line=0.2)
      on &lt;- rep(c(TRUE,FALSE),length.out=length(cutoff))
      graphics::axis(side=1,at=log(cutoff),labels=rep(&quot;&quot;,times=length(on)),cex.axis=0.7)
      graphics::axis(side=1,at=log(cutoff)[on],labels=paste0(cutoff[on],&quot;\n&quot;,&quot;(&quot;,number[on],&quot;)&quot;),cex.axis=0.7)
      graphics::axis(side=2,cex.axis=0.7)
      if(horizontal){
        graphics::abline(h=0.5,col=&quot;grey&quot;,lty=2)
        #graphics::abline(h=unique(table[[&quot;mean&quot;]][,alpha]),col=&quot;grey&quot;,lty=2)
      }
      for(i in 1:3){
        for(method in c(&quot;glmnet&quot;,paste0(&quot;transreg.&quot;,scale,c(&quot;.sta&quot;,&quot;.sim&quot;)),&quot;naive&quot;)){
          lty &lt;- switch(method,&quot;mean&quot;=1,&quot;glmnet&quot;=1,&quot;transreg.exp.sta&quot;=2,&quot;transreg.exp.sim&quot;=2,&quot;transreg.iso.sta&quot;=2,&quot;transreg.iso.sim&quot;=2,&quot;naive&quot;=3)
          col &lt;- switch(method,&quot;mean&quot;=&quot;grey&quot;,&quot;glmnet&quot;=&quot;black&quot;,&quot;transreg.exp.sta&quot;=rgb(0.2,0.2,1),&quot;transreg.iso.sta&quot;=rgb(0.2,0.2,1),&quot;transreg.exp.sim&quot;=rgb(0,0,0.6),&quot;transreg.iso.sim&quot;=rgb(0,0,0.6),&quot;naive&quot;=&quot;red&quot;)
          y &lt;- table[[method]][,alpha]
          x &lt;- log(as.numeric(names(y)))
          if(i==1){graphics::lines(x=x,y=y,col=col,lty=lty)}
          if(i==2){graphics::points(x=x,y=y,col=&quot;white&quot;,pch=16)}
          if(i==3){graphics::points(x=x,y=y,col=col)}
        }
      }
    }
  }
}

load(paste0(dir,&quot;/data/app_int_data.RData&quot;))
load(paste0(dir,&quot;/results/app_int.RData&quot;))
frame &lt;- frame[seq_along(loss),colnames(frame)!=&quot;seed&quot;]
cutoff &lt;- unique(frame$cutoff)
number &lt;- unique(sapply(loss,function(x) x$p))

auc &lt;- as.data.frame(t(sapply(loss,function(x) x$auc)))
table &lt;- lapply(auc,function(x) tapply(X=x,INDEX=list(frame$cutoff,frame$alpha),FUN=function(x) mean(x)))

#grDevices::pdf(file=paste0(dir,&quot;/manuscript/figure_int.pdf&quot;),width=8,height=6,pointsize=15)
#grDevices::png(file=paste0(dir,&quot;/manuscript/figure_int.png&quot;),width=8,height=6,units=&quot;in&quot;,pointsize=15,res=1200)
grDevices::postscript(file=paste0(dir,&quot;/manuscript/figure_int.eps&quot;),width=8,height=6,pointsize=15,horizontal=FALSE,paper=&quot;special&quot;)
plotter(table,cutoff,number,horizontal=TRUE)
grDevices::dev.off()
</code></pre>
<p>This chunk obtains the upper \(95\%\) confidence interval of a random classifier with \(766\) controls and \(790\) cases (result: \(0.524\)).</p>
<ul>
<li>
<p>input: -</p>
</li>
<li>
<p>execution time: some seconds</p>
</li>
<li>
<p>output: not saved</p>
</li>
</ul>
<pre><code class="language-r">#--- empirical computation of confidence interval ---

set.seed(1)
auc &lt;- list()
n &lt;- c(&quot;small&quot;,&quot;large&quot;)
for(i in seq_along(n)){
  auc[[i]] &lt;- numeric()
  for(j in 1:10000){
    if(n[i]==&quot;small&quot;){
      y &lt;- rep(c(0,1),times=c(50,50))
    }
    if(n[i]==&quot;large&quot;){
      y &lt;- rep(c(0,1),times=c(766,790))
    }
    x &lt;- stats::runif(n=length(y),min=0,max=1)
    
    auc[[i]][j] &lt;- pROC::auc(response=y,predictor=x,direction=&quot;&lt;&quot;,levels=c(0,1))
  }
}
q &lt;- sapply(auc,function(x) quantile(x,probs=0.95))
graphics::par(mar=c(3.5,3.5,1,1))
graphics::plot.new()
graphics::plot.window(xlim=c(0.5,length(n)+0.5),ylim=range(auc))
graphics::box()
graphics::axis(side=1,at=seq_along(n),labels=n)
graphics::axis(side=2)
for(i in seq_along(n)){
  graphics::boxplot(x=auc[[i]],at=i,add=TRUE)
}
graphics::abline(h=0.5)
graphics::title(xlab=&quot;sample size&quot;,ylab=&quot;AUC&quot;,line=2.5)
graphics::segments(x0=seq_along(n)-0.2,x1=seq_along(n)+0.2,y0=q,col=&quot;red&quot;,lwd=2)
graphics::text(x=seq_along(n)-0.2,y=q,labels=round(q,digits=3),pos=2,cex=0.5,col=&quot;red&quot;)
q

#--- analytical calculation of confidence interval ---

# This code is based on the website &quot;Real Statistics using Excel&quot; from Charles Zaiontz, https://real-statistics.com/descriptive-statistics/roc-curve-classification-table/auc-confidence-interval/).

var_AUC &lt;- function(x,n1,n2) {
  q1 = x/(2-x)
  q2 = 2*x^2/(1+x)
  var = (x*(1-x) +(n1-1)*(q1-x^2) +(n2-1)*(q2-x^2))/(n1*n2)
}
round(0.5 + stats::qnorm(p=0.95)*sqrt(var_AUC(0.5,n1=50,n2=50)),digits=3)
round(0.5 + stats::qnorm(p=0.95)*sqrt(var_AUC(0.5,n1=766,n2=790)),digits=3)
</code></pre>
<h1 id="further-research">Further research</h1>
<p>Additional code for further research (not included in the manuscript): [see source].</p>
<pre><code class="language-r">#--- This code chunk is not included in the manuscript! ---

# The following chunk performs the additional simulation study with either linearly or non-linearly related prior effects for the comparison of transreg and xrnet.

set.seed(1)

temp &lt;- matrix(data=NA,nrow=10,ncol=2,dimnames=list(NULL,c(&quot;transreg&quot;,&quot;xrnet&quot;)))
mse &lt;- list(linear=temp,nonlinear=temp)

for(i in c(&quot;linear&quot;,&quot;nonlinear&quot;)){
  for(j in 1:10){
    
    # simulate data
    n0 &lt;- 100; n1 &lt;- 10000; n &lt;- n0 + n1; p &lt;- 2000
    X &lt;- matrix(stats::rnorm(n*p),nrow=n,ncol=p)
    beta &lt;- stats::rnorm(n=p)*stats::rbinom(n=p,size=1,prob=0.05)
    y &lt;- stats::rnorm(n=n,mean=X %*% beta,sd=1) #sd(X %*% beta)
    
    # relation between prior effects and true effects
    temp &lt;- beta + stats::rnorm(n=p)*stats::rbinom(n=p,size=1,prob=0.01)
    # temp &lt;- beta + stats::rnorm(p,sd=0.1) # for comparison
    if(i==&quot;linear&quot;){
      prior &lt;- temp
    } else if(i==&quot;nonlinear&quot;){
      prior &lt;- sign(temp)*abs(temp)^2
    }
    
    # hold-out
    y_hat &lt;- list()
    foldid &lt;- rep(c(0,1),times=c(n0,n1))
    
    # transfer learning with transreg
    model &lt;- transreg::transreg(y=y[foldid==0],X=X[foldid==0,],prior=prior)
    y_hat$transreg &lt;- predict(model,newx=X[foldid==1,])
    
    # transfer learning with xrnet
    model &lt;- xrnet::tune_xrnet(x=X[foldid==0,],y=y[foldid==0],external=as.matrix(prior,ncol=1))
    y_hat$xrnet &lt;- stats::predict(model,newdata=X[foldid==1,])
    
    # mean squared error (MSE)
    mse[[i]][j,] &lt;- sapply(y_hat,function(x) mean((x-y[foldid==1])^2))
    
  }
}

# linear scenario
sum(mse$linear[,&quot;xrnet&quot;] &lt; mse$linear[,&quot;transreg&quot;])
stats::wilcox.test(x=mse$linear[,&quot;xrnet&quot;],y=mse$linear[,&quot;transreg&quot;],paired=TRUE)$p.value

# non-linear scenario
sum(mse$nonlinear[,&quot;transreg&quot;] &lt; mse$nonlinear[,&quot;xrnet&quot;])
stats::wilcox.test(x=mse$nonlinear[,&quot;transreg&quot;],y=mse$nonlinear[,&quot;xrnet&quot;],paired=TRUE)$p.value
</code></pre>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>Reformat list of consortium members for acknowledgements: [see source].</p>
<h1 id="session-information">Session information</h1>
<p>Print session information.</p>
</div>
<div class="include-after">
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js" defer></script>
</body>
</html>
